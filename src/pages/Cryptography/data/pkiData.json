{
    "header": {
        "title": "Infraestructura de clave pública (PKI)",
        "description": "Arquitectura, estándares y la realidad del despliegue en la confianza digital."
    },
    "menu": [
        {
            "id": "intro",
            "label": "El dilema"
        },
        {
            "id": "ecosystem",
            "label": "Ecosistema de confianza"
        },
        {
            "id": "lifecycle",
            "label": "Ciclo de vida y validación"
        },
        {
            "id": "x509",
            "label": "Estándares X.509"
        },
        {
            "id": "revocation",
            "label": "Mecanismos de revocación"
        },
        {
            "id": "pkcs",
            "label": "Normas PKCS y RSA avanzado"
        },
        {
            "id": "representation",
            "label": "Datos: ASN.1, DER, PEM"
        },
        {
            "id": "lab-pki-complete",
            "label": "Taller OpenSSL: gestión de certificados"
        },
        {
            "id": "lab-mtls",
            "label": "Taller OpenSSL: Autenticación mTLS"
        },
        {
            "id": "practice",
            "label": "Casos de estudio y riesgos reales"
        },
        {
            "id": "risks",
            "label": "Riesgos en la gestión"
        }
    ],
    "content": {
        "intro": {
            "title": "El dilema de la identidad",
            "subtitle": "La incertidumbre de la identidad en el espacio cifrado",
            "description": "En el ámbito de la seguridad de la información, la criptografía de clave pública resolvió con elegancia el problema de la distribución de secretos. Sin embargo, esta solución técnica introdujo un dilema ontológico: la incertidumbre de la identidad. ¿Cómo podemos asegurar que una clave pública pertenece efectivamente a la entidad que dice ser su titular? Sin una respuesta robusta, el sistema colapsa ante ataques de suplantación y de 'hombre en el medio'.\n\nLa <strong class='text-success'>Infraestructura de Clave Pública (PKI*)</strong> se constituye como la respuesta sistémica a este vacío. No se limita a un mero despliegue de software; representa un ecosistema complejo de procesos, roles y especificaciones técnicas diseñadas para vincular identidades con sus respectivas claves mediante certificados digitales. Esta infraestructura es, en esencia, el andamiaje sobre el que descansa la confianza digital en entornos abiertos, permitiendo que la autenticidad, la integridad y el no repudio dejen de ser conceptos teóricos para convertirse en realidades operativas.<br/><br/><span class='text-xs italic text-(--text-tertiary)'>* Public Key Infrastructure</span>",
            "icon": "Fingerprint"
        },
        "lab-pki-complete": {
            "title": "Taller OpenSSL: gestión de certificados",
            "subtitle": "Simulación de una autoridad de certificación (CA) corporativa",
            "description": "En este escenario avanzado de ingeniería, asumiremos el rol de arquitectos de seguridad de una organización ficticia 'Laboratorio Corp'. Construiremos una CA raíz de confianza desde cero, emitiremos certificados para nuestros servidores web y verificaremos la cadena de confianza completa.",
            "steps": [
                {
                    "title": "Paso 1: Creación de la autoridad de certificación (CA)",
                    "desc": "Generamos la llave privada y el certificado raíz de nuestra entidad de confianza. Usamos RSA de 4096 bits para máxima seguridad y una validez estándar de 1 año para laboratorio.",
                    "content": "# 1. Generar la clave privada de la CA (con password robusta)\nopenssl genrsa -aes256 -out laboratorio-ca.key 4096\n\n# 2. Generar el certificado auto-firmado de la CA (Root Certificate)\n# -x509: El estándar que define CAs mediante autofirma\n# -days 365: Validez de un año\n# -subj: Automatiza los datos (CN=Laboratorio Root CA)\n\nopenssl req -new -x509 -days 365 -key laboratorio-ca.key -sha256 -out laboratorio-ca.crt -subj \"/C=GB/ST=England/L=London/O=Laboratorio Corp/CN=Laboratorio Root CA\""
                },
                {
                    "title": "Paso 2: Generación de clave y CSR para el servidor",
                    "desc": "Preparamos la identidad del servidor web (london-secure.com). Creamos su clave privada (2048 bits es suficiente para servidores finales) y la Solicitud de Firma de Certificado (CSR).",
                    "content": "# 1. Generar clave privada del servidor (sin password para arranque automático)\nopenssl genrsa -out servidor.key 2048\n\n# 2. Crear la solicitud de firma (CSR)\n# Es CRÍTICO que el Common Name (CN) coincida con el dominio\n\nopenssl req -new -key servidor.key -out servidor.csr -subj \"/C=GB/ST=England/L=London/O=Servicios Web/CN=london-secure.com\""
                },
                {
                    "title": "Paso 3: Definición de extensiones (SAN)",
                    "desc": "Los navegadores modernos (Chrome/Edge) exigen el campo Subject Alternative Name (SAN). Creamos un archivo de configuración para inyectar esta extensión.",
                    "content": "# Crear archivo de configuración de extensiones v3.ext\n# Esto define que el certificado es para servidor y su DNS alternativo\n\necho \"authorityKeyIdentifier=keyid,issuer\nbasicConstraints=CA:FALSE\nkeyUsage = digitalSignature, keyEncipherment\nextendedKeyUsage = serverAuth\nsubjectAltName = @alt_names\n\n[alt_names]\nDNS.1 = london-secure.com\" > v3.ext"
                },
                {
                    "title": "Paso 4: Firma del certificado",
                    "desc": "La CA actúa como notario digital y valida la solicitud (CSR), emitiendo un certificado válido firmado con su clave raíz y las extensiones SAN.",
                    "content": "# Firmar la CSR con la clave de la CA y las extensiones SAN\n# -CA: Certificado de la autoridad\n# -CAkey: Clave privada de la autoridad\n# -CAcreateserial: Crea número de serie único\n\nopenssl x509 -req -in servidor.csr -CA laboratorio-ca.crt -CAkey laboratorio-ca.key -CAcreateserial -out servidor.crt -days 365 -sha256 -extfile v3.ext\n\n# Inspeccionar el certificado (Verificar emisor, sujeto y extensiones)\nopenssl x509 -in servidor.crt -text -noout"
                },
                {
                    "title": "Paso 5: Despliegue y prueba de fallo (Untrusted)",
                    "desc": "Levantamos el servidor y simulamos el acceso. Como el sistema operativo AÚN NO confía en nuestra CA casera, el navegador debe protegernos bloqueando la conexión.",
                    "content": "# 1. Mapear dominio local (Hosts)\n# Editamos hosts para que 'london-secure.com' apunte a mi máquina (127.0.0.1)\n# [Win]: drivers/etc/hosts | [Linux/Mac]: /etc/hosts\n\n# 2. Arrancar servidor HTTPS en puerto 443\nopenssl s_server -cert servidor.crt -key servidor.key -www -accept 443\n\n# 3. Prueba de acceso (Fallo esperado)\n# Navega a https://london-secure.com\n# RESULTADO: Alerta de seguridad 'NET::ERR_CERT_AUTHORITY_INVALID'.\n# Esto es CORRECTO: El sistema no conoce a 'Laboratorio Corp'."
                },
                {
                    "title": "Paso 6: Estableciendo la confianza (Trust)",
                    "desc": "Cerramos el círculo. Instalamos el certificado raíz de nuestra CA en el almacén de confianza del sistema. Ahora, el navegador verificará la firma, verá que confía en el firmante (nosotros) y mostrará el candado verde.",
                    "content": "# Con el servidor aún corriendo:\n\n# 1. Instalar 'laboratorio-ca.crt' (Ver nota abajo para tu SO)\n# 2. Reiniciar el navegador (Crucial para que lea el nuevo almacén)\n# 3. Acceder de nuevo a https://london-secure.com\n\n# RESULTADO: Candado Verde y acceso permitido.\n# Has creado tu propia identidad digital confiable.",
                    "note": "[Win Home]: Doble clic .crt > Instalar > Máquina local > 'Entidades de certificación raíz de confianza'.\n[Win Pro]: Ejecutar 'certmgr.msc' > Importar en 'Entidades de certificación raíz'.\n[MacOS]: Llaveros > Sistema > Arrastrar .crt > Doble clic > Confiar > 'Confiar siempre'.\n[Linux]: cp laboratorio-ca.crt /usr/local/share/ca-certificates/ && update-ca-certificates"
                }
            ],
            "icon": "Terminal"
        },
        "ecosystem": {
            "title": "El ecosistema de confianza",
            "subtitle": "Entidades de una PKI y separación de funciones",
            "description": "Una <strong class='text-success'>PKI</strong> no es un bloque monolítico, sino una arquitectura de separación de funciones diseñada para maximizar la seguridad y la escalabilidad. La distribución de responsabilidades es un imperativo para mitigar riesgos críticos: comprometer un componente no debe implicar la caída de todo el sistema.",
            "entities": [
                {
                    "name": "Autoridad de Certificación (CA)",
                    "desc": "Es el eje central de confianza y el corazón criptográfico del sistema. Su función primordial es certificar el vínculo inquebrantable entre una identidad (sujeto) y un par de claves mediante la firma digital de certificados.<br/><br/><strong class='text-success'>Responsabilidad crítica:</strong> No solo emite, sino que es la responsable última de gestionar la revocación de dicho vínculo, publicando las CRLs. En entornos de alta seguridad, la <strong>CA Raíz</strong> suele operar <em>offline</em> (fuera de línea) en una cámara acorazada para minimizar su superficie de ataque, delegando la emisión diaria en CAs Subordinadas."
                },
                {
                    "name": "Autoridad de Registro (RA)",
                    "desc": "Actúa como el brazo operativo y la interfaz humana para la verificación de identidad (Front-End). Su papel es validar al solicitante mediante procedimientos rigurosos que pueden incluir la personación física y la presentación de documentos oficiales (DNI o pasaporte).<br/><br/><strong class='text-success'>Separación de funciones:</strong> En despliegues masivos, la separación entre la CA y la RA es fundamental: mientras que la CA se mantiene en un búnker digital altamente protegido, la RA gestiona la capilaridad y el contacto con el usuario final, optimizando la escalabilidad y permitiendo validar identidades en múltiples ubicaciones geográficas sin exponer las claves maestras."
                },
                {
                    "name": "Autoridad de Validación (VA)",
                    "desc": "Especializada exclusivamente en la comprobación del estado de vigencia de los certificados en tiempo real. Su existencia libera a la CA de la inmensa carga transaccional de responder a millones de consultas de validez por segundo.<br/><br/>Utiliza protocolos como <strong>OCSP (Online Certificate Status Protocol)</strong> para informar si un certificado específico sigue siendo válido, ha sido revocado o está suspendido, sin necesidad de que el cliente descargue listas de revocación completas."
                },
                {
                    "name": "Autoridad de Sellado de Tiempo (TSA)",
                    "desc": "Provee sellos de tiempo confiables que demuestran matemáticamente la existencia de un dato en un instante `t` preciso. Mediante una firma digital sobre el hash del documento combinada con una marca de tiempo UTC fiable.<br/><br/><strong class='text-success'>Valor legal y técnico:</strong> Permite la validación de firmas digitales a largo plazo (LTV), incluso después de que el certificado original del firmante haya expirado o sido revocado, siempre que se pueda probar matemáticamente que la firma se realizó <em>antes</em> de la pérdida de validez del certificado."
                },
                {
                    "name": "Marcos Normativos (CP y CPS)",
                    "desc": "La confianza no es abstracta ni arbitraria; se codifica en documentos legales y técnicos vinculantes:<br/><ul class='list-disc list-inside mt-2 space-y-1 text-sm'><li><strong class='text-success'>Política de Certificación (CP):</strong> Establece el 'qué'. Define el marco general, los niveles de seguridad y los usos permitidos del certificado (ej. para firma de contratos de alto valor vs. autenticación simple).</li><li><strong class='text-success'>Declaración de Prácticas de Certificación (CPS):</strong> Establece el 'cómo'. Detalla minuciosamente los procedimientos operativos, controles físicos, criptográficos y de personal que la CA sigue para cumplir con la CP.</li></ul>"
                }
            ],
            "icon": "Sitemap"
        },
        "lab-mtls": {
            "title": "Taller OpenSSL: Autenticación Mutua (mTLS)",
            "subtitle": "Autenticación de desarrolladores",
            "description": "Ahora que tenemos un servidor seguro, debemos garantizar que solo los desarrolladores autorizados de 'Laboratorio Corp' puedan acceder a áreas restringidas. Implementaremos <strong class='text-success'>mTLS (Mutual TLS)</strong>, donde el servidor también autentica al cliente solicitando su certificado personal.",
            "steps": [
                {
                    "title": "Paso 1: Generar identidad del desarrollador",
                    "desc": "Creamos la clave privada y la solicitud (CSR) para el desarrollador. Es vital diferenciar roles: estos no son certificados de servidor, sino de 'Autenticación de Cliente'. Indique su email corporativo en el campo OU.",
                    "content": "# 1. Generar clave privada del desarrollador\nopenssl genrsa -out desarrollador.key 2048\n\n# 2. Generar CSR del cliente (Incluir email en OU)\n# IMPORTANTE: CN debe ser el nombre del desarrollador\nopenssl req -new -key desarrollador.key -out desarrollador.csr -subj \"/C=GB/ST=England/L=London/O=Laboratorio Corp/OU=admin@uoc.edu/CN=Desarrollador Senior\""
                },
                {
                    "title": "Paso 2: Firma con extensiones (clientAuth)",
                    "desc": "El usuario no es un servidor. Debemos indicar explícitamente en el certificado que su uso legítimo es la autenticación de cliente (clientAuth). Si no lo hacemos, algunos servidores estrictos podrían rechazarlo.",
                    "content": "# 1. Crear perfil de extensiones para Cliente\necho \"extendedKeyUsage = clientAuth, emailProtection\" > cliente.ext\n\n# 2. Firmar el certificado aplicando las restricciones\n# -extfile cliente.ext: Inyecta las reglas de uso\nopenssl x509 -req -days 365 -in desarrollador.csr -CA laboratorio-ca.crt -CAkey laboratorio-ca.key -CAcreateserial -out desarrollador.crt -sha256 -extfile cliente.ext"
                },
                {
                    "title": "Paso 3: Empaquetar credenciales (PKCS#12)",
                    "desc": "El formato <strong>PKCS#12</strong> (extensión .p12 o .pfx) es un <strong>'maletín digital'</strong> cifrado. Actúa como un contenedor portable que almacena simultáneamente tu <strong>Clave Privada</strong> (tu identidad secreta) y tu <strong>Certificado Público</strong> (tu credencial), protegidos por una contraseña única. Es el estándar universal para transportar identidades digitales completas e instalarlas en navegadores o sistemas operativos.",
                    "content": "# Exportar a PKCS#12 (Requiere password de exportación)\n# Este archivo 'desarrollador.p12' es lo que se instala en el navegador\nopenssl pkcs12 -export -out desarrollador.p12 -inkey desarrollador.key -in desarrollador.crt -certfile laboratorio-ca.crt"
                },
                {
                    "title": "Paso 4: Configurar servidor mTLS",
                    "desc": "Levantamos nuevamente el servidor, pero esta vez FORZAMOS la validación del certificado cliente (-Verify 1). Si el cliente no presenta un certificado firmado por nuestra CA, la conexión se rechaza.",
                    "content": "# Arrancar servidor en modo mTLS\n# -Verify 1: Solicita y verifica el certificado del cliente (profundidad 1)\n# -CAfile: La lista de CAs en las que el servidor confía para validar clientes\n\nopenssl s_server -cert servidor.crt -key servidor.key -www -accept 443 -Verify 1 -CAfile laboratorio-ca.crt"
                },
                {
                    "title": "Paso 5: Autenticación exitosa",
                    "desc": "Importamos el .p12 en el navegador y accedemos. El servidor validará criptográficamente nuestra identidad.",
                    "content": "# 1. Importar 'desarrollador.p12' en el navegador (Almacén Personal)\n# 2. Acceder a https://london-secure.com\n# 3. El navegador solicitará qué certificado usar (Client Certificate Selection)\n# 4. Seleccionar 'Desarrollador Senior'\n\n# RESULTADO: Acceso concedido + Detalles del certificado cliente en la respuesta HTML.",
                    "note": "[Chrome/Edge]: Configuración > Privacidad > Seguridad > Gestionar certificados > Personal > Importar (.p12).\n[Firefox]: Ajustes > Privacidad > Certificados > Ver certificados > Sus certificados > Importar."
                }
            ],
            "icon": "User"
        },
        "lifecycle": {
            "title": "La ontología del certificado",
            "subtitle": "Ciclo de vida, generación y validación",
            "definition": "Un certificado digital de clave pública es una estructura de datos que vincula una clave pública a una identidad. Esta vinculación se produce haciendo que una autoridad de certificación de confianza firme el certificado digital.",
            "csr_title": "Registro y Solicitud (CSR)",
            "csr_desc": "Tras la validación de identidad, se inicia el proceso técnico con la emisión de una <strong class='text-success'>Solicitud de Firma de Certificado (CSR*)</strong>, habitualmente bajo el estándar <strong>PKCS#10</strong>. Esta estructura de datos contiene la clave pública del solicitante y su información de identidad, firmada con la correspondiente clave privada para demostrar la 'Prueba de Posesión' (POP). Solo tras verificar esta firma interna, la CA procede a firmar y emitir el certificado X.509 final.<br/><br/><span class='text-xs italic text-gray-500'>* Certificate Signing Request</span>",
            "generation": [
                {
                    "method": "Por el usuario (Client-Side)",
                    "desc": "El titular genera sus claves en su propio equipo (navegador/servidor). Es el método <strong>ideal para el no repudio</strong>, ya que garantiza matemáticamente que solo el titular ha tenido acceso a la clave privada en todo momento. Nadie más, ni siquiera la CA, la ha visto."
                },
                {
                    "method": "Por la CA o RA (Server-Side)",
                    "desc": "Aprovecha la infraestructura profesional de la autoridad para generar el par de claves. Facilita la gestión y recuperación a usuarios no técnicos, pero introduce un <strong>riesgo de seguridad</strong>: existe una copia de la clave privada (Key Escrow implícito) fuera del control exclusivo del titular."
                },
                {
                    "method": "Por una tercera parte",
                    "desc": "Delegación en una entidad externa de confianza que genera las claves y las entrega de forma segura (ej. tarjeta inteligente pre-cargada). Exige procedimientos estrictos de <strong>destrucción del material</strong> criptográfico tras la entrega."
                },
                {
                    "method": "En hardware especializado (HSM/Smart Card)",
                    "desc": "El nivel máximo de seguridad (ej. <strong>DNI electrónico</strong>). La clave se genera dentro de un chip criptográfico seguro y es técnicamente <strong>imposible de extraer</strong>. Las operaciones de firma ocurren dentro del propio chip, garantizando que la clave privada nunca se expone a la memoria del ordenador."
                }
            ],
            "validation_intro": "Tras la validación de identidad, se emite una Solicitud de Firma de Certificado (CSR) —habitualmente bajo el estándar PKCS#10— que contiene la clave pública del solicitante. Una vez emitido el certificado, cualquier entidad que desee confiar en él debe ejecutar un riguroso protocolo de validación:",
            "validation": [
                "<strong class='text-warning'>Integridad:</strong> Validación criptográfica de la firma de la CA. Se descifra la firma del certificado con la clave pública de la CA y se compara con el hash del contenido. Cualquier discrepancia indica manipulación.",
                "<strong class='text-warning'>Temporalidad:</strong> Verificación estricta de las fechas <code>notBefore</code> y <code>notAfter</code>. El certificado es inválido fuera de esa ventana temporal exacta.",
                "<strong class='text-warning'>Revocación:</strong> Consulta obligatoria a las listas negras. Se verifica contra la <strong>CRL</strong> más reciente o mediante una consulta <strong>OCSP</strong> en tiempo real para asegurar que el certificado no ha sido anulado antes de su expiración.",
                "<strong class='text-warning'>Uso de clave (Key Usage):</strong> Comprobación semántica. Se verifica si el certificado permite la operación intentada (ej. asegurar que un certificado de 'Firma de Email' no se use para firmar un ejecutable) revisando las extensiones <code>KeyUsage</code>.",
                "<strong class='text-warning'>Cadena de confianza:</strong> Construcción de la ruta de certificación (Certification Path). Se verifica la firma de la CA emisora, luego la de la CA que firmó a esta, recursivamente hasta llegar a una <strong>CA Raíz</strong> de confianza preinstalada en el sistema (Root Store)."
            ],
            "icon": "FileBadge"
        },
        "x509": {
            "title": "Estándares X.509",
            "subtitle": "El ADN de la identidad digital",
            "description": "El estándar <strong class='text-info'>X.509 v3</strong> (ITU-T) define la estructura técnica predominante para los certificados de clave pública. Es fundamental diferenciar conceptualmente dos tipos de certificados en este ecosistema:<br/><br/><ul class='list-disc list-inside space-y-2 ml-4'><li><strong>Certificado de Clave Pública (PKC):</strong> Vincula una identidad a una clave (responde a <em>'¿Quién eres?'</em>).</li><li><strong>Certificado de Atributos (AC):</strong> Vincula privilegios, roles o atributos a un poseedor, separando la identidad de la autorización (responde a <em>'¿Qué puedes hacer?'</em>).</li></ul><br/>Esta separación permite diseñar arquitecturas de seguridad modulares y escalables.",
            "critical_fields": [
                {
                    "field": "serialNumber",
                    "desc": "Entero único asignado por la CA emisor. Junto con el nombre del emisor, forma un identificador globalmente único para el certificado."
                },
                {
                    "field": "issuer",
                    "desc": "El <strong>Distinguished Name (DN)</strong> de la autoridad que firma y emite el certificado. Es la entidad que avala la identidad contenida."
                },
                {
                    "field": "validity",
                    "desc": "Intervalo temporal estricto definido por <code>notBefore</code> (inicio) y <code>notAfter</code> (expiración). Fuera de este rango, el certificado carece de toda validez técnica."
                },
                {
                    "field": "subject",
                    "desc": "Identificación del titular de la clave pública (DN). En certificados modernos web (TLS), este campo puede estar vacío si la identidad se define completamente en la extensión <code>SubjectAltName</code> (SAN)."
                },
                {
                    "field": "subjectPublicKeyInfo",
                    "desc": "El corazón del certificado. Contiene el algoritmo criptográfico usado (ej. RSA, ECDSA) y el valor binario de la clave pública en sí misma."
                }
            ],
            "extensions_intro": "Las extensiones (X.509 v3) dotan de flexibilidad y extensibilidad al estándar sin romper la compatibilidad. Cada extensión incluye un indicador vital: el <strong>Flag de Criticidad</strong>.",
            "extensions_logic": [
                {
                    "status": "CRITICAL = TRUE",
                    "behavior": "Si la aplicación procesadora NO reconoce o no entiende esta extensión, <strong>DEBE rechazar</strong> el certificado inmediatamente. Esto evita fallos de seguridad por ignorar restricciones importantes (ej. <em>Basic Constraints</em> que limitan si un cert puede firmar a otros)."
                },
                {
                    "status": "CRITICAL = FALSE",
                    "behavior": "Si la aplicación no reconoce la extensión, puede ignorarla y procesar el resto del certificado. Se usa para información informativa o accesoria (ej. detalles del emisor)."
                }
            ],
            "typology": [
                {
                    "name": "Certificados de Entidad Final",
                    "desc": "Pertenecen a usuarios, servidores (SSL/TLS) o dispositivos. <strong>No pueden</strong> emitir otros certificados. Son las 'hojas' del árbol de confianza."
                },
                {
                    "name": "Certificados de CA (Autoridad)",
                    "desc": "Tienen permiso para firmar otros certificados (bit <code>KeyCertSign</code> activo).",
                    "subtypes": [
                        "<strong>Autoemitidos (Self-Issued):</strong> Mismo titular y emisor, pero p.ej. diferentes claves.",
                        "<strong>Autofirmados (Self-Signed):</strong> Caso especial de la <strong>CA Raíz</strong>. La clave privada firma su propia clave pública, cerrando la cadena de confianza.",
                        "<strong>Certificados Cruzados (Cross-Certificates):</strong> Una CA firma la clave pública de otra CA independiente para establecer confianza mutua entre organizaciones diferentes (Bridge CA)."
                    ]
                }
            ],
            "icon": "FileCode"
        },
        "revocation": {
            "title": "Mecanismos de revocación",
            "subtitle": "Gestión de la desconfianza en tiempo real",
            "description": "La revocación es el mecanismo de seguridad más complejo y crítico de una PKI. Un certificado digital es inmutable y tiene una validez predefinida (ej. 1 año). Sin embargo, situaciones críticas como el <strong class='text-error'>compromiso de la clave privada</strong> o cambios organizativos requieren invalidar esa confianza <em>antes</em> de su expiración natural.<br/><br/>Sin un control de revocación efectivo, un atacante con una clave robada podría suplantar una identidad impunemente hasta la fecha de caducidad del certificado.",
            "methods": [
                {
                    "name": "CRL (Certificate Revocation Lists)",
                    "type": "Modelo asíncrono (Listas Negras)",
                    "desc": "La CA publica periódicamente un archivo firmado que contiene los números de serie de <strong>todos</strong> los certificados revocados que aún no han expirado.",
                    "pros": "<strong>Integridad:</strong> Alta (firmado por CA).<br/><strong>Archivo:</strong> Fácil de almacenar para auditorías.",
                    "cons": "<strong>Problema de escalabilidad:</strong> Las listas pueden crecer hasta tener un tamaño inmanejable (MBs).<br/><strong>Ventana de riesgo:</strong> Si la CRL se publica cada 24h, un certificado comprometido hoy será confiable hasta mañana.",
                    "icon": "FileWarning"
                },
                {
                    "name": "OCSP (Online Certificate Status Protocol)",
                    "type": "Modelo síncrono (Tiempo Real)",
                    "desc": "El cliente consulta directamente a un servidor (Responder) el estado de un único certificado específico. El servidor responde: <em>Good</em>, <em>Revoked</em> o <em>Unknown</em>.",
                    "pros": "<strong>Tiempo Real:</strong> Estado actualizado al segundo.<br/><strong>Eficiencia:</strong> No consume ancho de banda con listas gigantes.",
                    "cons": "<strong>Privacidad:</strong> La CA conoce qué sitios visita el usuario.<br/><strong>Latencia:</strong> Añade un RTT (Round Trip Time) al handshake.<br/><strong>Fragilidad:</strong> Si el servidor OCSP cae, el navegador debe decidir si bloquear (Hard-Fail) o permitir (Soft-Fail).",
                    "icon": "GlobeLock"
                }
            ],
            "stapling": {
                "title": "La Solución Moderna: OCSP Stapling",
                "desc": "Para resolver los problemas de privacidad y rendimiento del OCSP tradicional, se desarrolló el <strong>OCSP Stapling</strong> (TLS Certificate Status Request extension).<br/><br/>En este modelo, es el propio <strong>servidor web</strong> (no el cliente) quien consulta periódicamente a la CA, obtiene una prueba de validez firmada digitalmente y la 'agrapa' (staples) al certificado durante el saludo inicial (TLS Handshake). El cliente verifica la firma de la CA sobre esa respuesta sin necesidad de contactar a terceros, garantizando privacidad y velocidad."
            },
            "reasons_title": "¿Por qué se revoca un certificado?",
            "reasons_desc": "Cuando una CA invalida un certificado, debe indicar la causa (Reason Code, RFC 5280) para que los sistemas sepan cómo reaccionar. No es lo mismo un mero cambio administrativo que un robo de claves.",
            "reasons": [
                {
                    "name": "keyCompromise",
                    "id": 1,
                    "desc": "<strong class='text-error'>CRÍTICO:</strong> La clave privada ha sido robada o expuesta. Revocación inmediata."
                },
                {
                    "name": "affiliationChanged",
                    "id": 3,
                    "desc": "El titular ya no pertenece a la organización (ej. empleado despedido)."
                },
                {
                    "name": "cessationOfOperation",
                    "id": 5,
                    "desc": "El servidor o servicio ha dejado de existir o utilizarse."
                },
                {
                    "name": "superseded",
                    "id": 4,
                    "desc": "El certificado ha sido reemplazado por uno nuevo (ej. cambio de proveedor)."
                }
            ],
            "icon": "FileWarning"
        },
        "pkcs": {
            "title": "Estándares PKCS y RSA Avanzado",
            "subtitle": "De la teoría matemática a la seguridad industrial",
            "intro_problem": {
                "title": "¿Por qué el RSA 'básico' es inseguro?",
                "desc": "El RSA de libro de texto (determinista) es vulnerable. Si cifras el mismo mensaje <em>m</em> dos veces con la misma clave pública, obtienes el mismo criptograma <em>c</em>. Esto permite a un atacante identificar mensajes comunes.<br/><br/>Peor aún, posee una <strong>Propiedad Homomórfica</strong>: <code class='text-accent'>E(m1) · E(m2) = E(m1 · m2)</code> que habilita <strong>Ataques de Maleabilidad</strong>: un atacante puede modificar un criptograma cifrado interceptado para que, al ser descifrado por la víctima, se convierta en un mensaje diferente pero predecible, sin que el atacante necesite conocer la clave privada.",
                "vulnerabilities": [
                    "Determinismo (Cifrado de mensajes idénticos)",
                    "Maleabilidad (Modificación de criptogramas)",
                    "Ataques de exponente pequeño"
                ]
            },
            "oaep": {
                "title": "La Solución: RSAES-OAEP (PKCS#1)",
                "subtitle": "Optimal Asymmetric Encryption Padding (Esquema probabilístico)",
                "desc": "Para solucionar esto, PKCS#1 introduce <strong>OAEP</strong>, transformando RSA en un esquema <strong>probabilístico</strong> mediante una Red de Feistel.",
                "mechanism_steps": [
                    {
                        "step": "1. Construcción del bloque DB",
                        "detail": "<strong>DB = lHash || PS || 0x01 || M</strong><br/>Se concatena el hash de una etiqueta (lHash), un relleno de ceros (PS) semántico, un byte delimitador (0x01) y el mensaje (M)."
                    },
                    {
                        "step": "2. Generación de Máscara (MGF1)",
                        "detail": "Se usa una semilla aleatoria (seed). MGF1 genera una 'máscara' criptográfica expandiendo esta semilla mediante hashes iterativos."
                    },
                    {
                        "step": "3. Red de Feistel (XOR)",
                        "detail": "<strong>maskedDB = DB ⊕ MGF(seed)</strong><br/><strong>maskedSeed = seed ⊕ MGF(maskedDB)</strong><br/>Esta dependencia cruzada 'mezcla' todo. Alterar un solo bit del criptograma corrompe todo el bloque al descifrar (Integridad)."
                    }
                ]
            },
            "standards": [
                {
                    "id": "PKCS#5",
                    "name": "Password-Based Cryptography Standard",
                    "desc": "Crucial para proteger claves privadas en disco. Define <strong>PBKDF2</strong>: un KDF que usa:<br/>• <strong>Salt:</strong> Evita ataques de diccionario.<br/>• <strong>Iteraciones:</strong> (>1000) Frena la fuerza bruta.",
                    "icon": "Key"
                },
                {
                    "id": "PKCS#12",
                    "name": "Personal Information Exchange",
                    "desc": "El 'maletín seguro' (<code>.p12</code>, <code>.pfx</code>) para transportar identidades completas cifradas:<br/>• Clave Privada (vía PKCS#5)<br/>• Certificado de Usuario<br/>• Cadena de Confianza",
                    "icon": "Briefcase"
                },
                {
                    "id": "PKCS#10",
                    "name": "Certification Request Standard (CSR)",
                    "desc": "El formato estándar para solicitar un certificado. Contiene:<br/>• Clave Pública<br/>• Identidad (Subject)<br/>• Firma de la Clave Privada (Prueba de Posesión/PoP).",
                    "icon": "FileText"
                },
                {
                    "id": "PKCS#11",
                    "name": "Cryptographic Token Interface (Cryptoki)",
                    "desc": "API neutra para hardware criptográfico (HSM, Smart Cards). Permite realizar operaciones (firmar) <strong>dentro</strong> del chip, asegurando que la clave privada <strong>nunca</strong> salga al PC.",
                    "icon": "Cpu"
                }
            ],
            "icon": "BookOpen"
        },
        "representation": {
            "title": "Representación de datos",
            "subtitle": "De la abstracción al bit",
            "description": "Para que los sistemas criptográficos de todo el mundo se entiendan, los datos deben transformarse siguiendo una estricta cadena de montaje. No basta con 'enviar la clave'; hay que definir exactamente qué es, cómo se estructura y cómo se codifica.",
            "formats": [
                {
                    "name": "ASN.1 (Abstract Syntax Notation One)",
                    "role": "El Plano (Sintaxis)",
                    "desc": "Es el <strong>lenguaje de definición</strong>. Imagínalo como un 'JSON Schema' pero para telecomunicaciones y mucho más estricto. Define <strong>QUÉ</strong> datos existen (un número, una fecha, una secuencia), pero no dice nada sobre cómo se guardan en el disco.",
                    "example_title": "Definición ASN.1 de un certificado (simplificada):",
                    "example_code": "Certificate ::= SEQUENCE {\n  tbsCertificate       TBSCertificate,\n  signatureAlgorithm   AlgorithmIdentifier,\n  signatureValue       BIT STRING\n}"
                },
                {
                    "name": "DER (Distinguished Encoding Rules)",
                    "role": "El Cemento (Codificación)",
                    "desc": "Son las reglas para convertir ese plano ASN.1 en <strong>ceros y unos (binario)</strong> de forma única. A diferencia de otras reglas, DER asegura que un mismo objeto <strong>SIEMPRE</strong> produzca los mismos bytes exactos. <br/><br/><strong>¿Por qué es vital?</strong> Al firmar digitalmente, firmamos el hash de los bytes. Si la codificación variara (aunque el contenido semántico fuera el mismo), el hash cambiaría y la firma sería inválida. DER garantiza consistencia.",
                    "example_title": "Representación Hexadecimal (Binario):",
                    "example_code": "30 82 03 A8 30 82 02 90 A0 03 02 01 02 02 10 3E..."
                },
                {
                    "name": "PEM (Privacy-Enhanced Mail)",
                    "role": "El Sobre (Transporte)",
                    "desc": "El binario (DER) es ilegible y rompe correos electrónicos o copy-pastes. PEM soluciona esto codificando el bloque DER en <strong>Base64</strong> y añadiendo cabeceras de texto claro.",
                    "example_title": "Lo que ves en tu editor:",
                    "example_code": "-----BEGIN CERTIFICATE-----\nMIIDzTCCArWgAwIBAgIQPl...\n-----END CERTIFICATE-----"
                }
            ],
            "icon": "Code"
        },
        "practice": {
            "title": "Casos de estudio y riesgos reales",
            "subtitle": "Luces, sombras y riesgos reales",
            "intro_concept": "El despliegue de HTTPS a nivel global ha revelado debilidades estructurales que no existen en el papel. El problema fundamental reside en la <strong>centralización y transitividad de la confianza</strong>: cualquier Autoridad de Certificación (CA) en la que tu navegador confíe tiene el poder técnico de firmar un certificado válido para *cualquier* dominio del mundo (google.com, tu-banco.com), sin que el dueño real del dominio lo sepa.",
            "intro_title": "¿Por qué usamos este modelo si tiene vulnerabilidades?",
            "intro_text": "La PKI es, hoy por hoy, el <strong>único mecanismo escalable</strong> para asegurar Internet. Sin ella, no tendríamos identidad digital. No es que la tecnología sea insegura (RSA funciona); lo que falla es la <strong>Delegación de Confianza</strong>. Si le das las llaves de tu casa a 100 porteros (CAs), basta con que uno sea corrupto para que te roben. Aquí analizamos esos fallos para aprender a mitigarlos.",
            "cases": [
                {
                    "title": "Incidente Trustwave",
                    "subtitle": "Sub-CA para vigilancia",
                    "summary": "Una CA raíz vendió su poder a una empresa para espiar empleados.",
                    "description": "<p>Trustwave, una Autoridad de Certificación confiable, emitió una CA Subordinada a una empresa privada. Esto permitió a dicha empresa generar certificados válidos (man-in-the-middle) para <strong>cualquier dominio</strong> (Google, Bancos, etc.) dentro de su red corporativa.</p><br/><p><strong>La lección:</strong> El modelo de negocio de las CAs puede entrar en conflicto con la seguridad global. La confianza es 'transitiva' y peligrosa.</p>",
                    "type": "failure",
                    "color": "error",
                    "badgeText": "2012",
                    "icon": "ShieldAlert"
                },
                {
                    "title": "NIC India & ANSSI",
                    "subtitle": "Incompetencia Gubernamental",
                    "summary": "Emisión de certificados fraudulentos para dominios globales.",
                    "description": "<p>El Centro Nacional de Informática de India (NIC) emitió certificados falsos para dominios de Google y Yahoo. Un caso similar ocurrió con la agencia francesa ANSSI. Esto demostró que incluso agencias gubernamentales pueden tener fallos críticos en sus procesos de validación.</p>",
                    "type": "failure",
                    "color": "error",
                    "badgeText": "2014",
                    "icon": "ShieldAlert"
                },
                {
                    "title": "Certificate Pinning",
                    "subtitle": "La Defensa Técnica",
                    "summary": "Confiar en la clave, no en la cadena.",
                    "description": "<p>Para combatir la debilidad de las CAs, nace el <strong>Pinning</strong>. En lugar de confiar en 'cualquier certificado firmado por una CA raíz', la aplicación (ej: App móvil de Banco) tiene <strong>'pineada' (incrustada en su código fuente)</strong> la clave pública real (o su hash) del servidor legítimo.</p><br/><p>Cuando la app se conecta, verifica: <br/>1. ¿El certificado es válido? (Check estándar).<br/>2. <strong>¿La clave pública del certificado coincide con la que tengo guardada en el código?</strong></p><br/><p>Si una CA corrupta emite un certificado falso para ese dominio, la cadena será válida (pasará el paso 1), pero <strong>la clave pública será distinta</strong> (fallará el paso 2), y la conexión se rechazará inmediatamente, protegiendo al usuario incluso ante CAs comprometidas.</p>",
                    "type": "defense",
                    "color": "success",
                    "badgeText": "Defensa",
                    "icon": "ShieldCheck"
                }
            ],
            "icon": "GlobeLock"
        },
        "risks": {
            "title": "Hacia una confianza robusta",
            "content": "Hemos recorrido desde la ontología de X.509 hasta la lógica de RSAES-OAEP. La PKI es robusta en su teoría, pero frágil en su implementación humana y administrativa. El DNI electrónico 3.0 ejemplifica la excelencia técnica mediante la separación de funciones (pares de claves distintos para Autenticación y Firma), pero también subraya el fracaso de la usabilidad en el mundo real.<br/><br/>La pregunta que debemos trasladar al futuro es de índole arquitectónica: <span class='text-success font-bold'>en un mundo que tiende a la descentralización, ¿es sostenible mantener la confianza global delegada en unos pocos centenares de autoridades de certificación, o es el momento de transitar hacia modelos de confianza distribuidos y resilientes?</span>",
            "icon": "ShieldCheck"
        }
    },
    "quote": {
        "text": "Si crees que la tecnología puede resolver tus problemas de seguridad, entonces no entiendes los problemas y no entiendes la tecnología.",
        "author": "Bruce Schneier"
    }
}